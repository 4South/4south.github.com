<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: View | Trial By Fire]]></title>
  <link href="http://stevekane.github.com/blog/categories/view/atom.xml" rel="self"/>
  <link href="http://stevekane.github.com/"/>
  <updated>2013-03-15T03:27:58-05:00</updated>
  <id>http://stevekane.github.com/</id>
  <author>
    <name><![CDATA[Steve Kane (@stv_kn)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamic Ember View Updating]]></title>
    <link href="http://stevekane.github.com/blog/2013/03/13/dynamic-selection-box/"/>
    <updated>2013-03-13T22:40:00-05:00</updated>
    <id>http://stevekane.github.com/blog/2013/03/13/dynamic-selection-box</id>
    <content type="html"><![CDATA[<h2>Dependencies</h2>

<p>The code for this post is built with Ember.js 1.0.0-RC1, handlebars RC3, and jQuery 1.9.1</p>

<h2>Objective</h2>

<p>We will see how the <strong>Ember.View</strong> updates when changing the model properties using mouse event coordinates. The end result is drawing a box which is an <strong>Ember.Object</strong> using click and drag.</p>

<h3>Demo</h3>

<p>This jsFiddle demonstrates the end result: <a href="http://jsfiddle.net/chen_pete/5m95y/10/">Completed Fiddle</a>.
Click on the gray box and hold down the mouse button. Drag to create and update a box object.</p>

<h2>Ember Application Setup</h2>

<p>Here we have defined two handlebars templates. The first is unnamed and will be used by the <strong>Application View</strong>.
The second is called "box" using data-template-name and will be used by the <strong>Box View</strong>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-handlebars&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="p">{{</span> <span class="nx">outlet</span> <span class="p">}}</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-handlebars&quot;</span> <span class="na">data-template-name =</span><span class="err"> </span><span class="s">&quot;box&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="p">{{</span><span class="nx">content</span><span class="p">.</span><span class="nx">text</span> <span class="p">}}</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here we setup the App, Router, Routes, and Ember Object.</p>

<p>```coffeescript</p>

<h1>SETUP APPLICATION</h1>

<p>App = Ember.Application.create()
App.Router.map () ->
  @resource "box"</p>

<p>App.IndexRoute = Em.Route.extend
   redirect: -></p>

<pre><code>    @replaceWith 'box'
</code></pre>

<p>App.BoxRoute = Em.Route.extend()</p>

<p>App.Box = Ember.Object.extend</p>

<pre><code>height: 0
width: 0
top: 0
left: 0
text: 'YAY COMIC SANS'
</code></pre>

<p>```</p>

<h2>Application View / Controller</h2>

<p>The <strong>Application View</strong> and <strong>Controller</strong> will be auto-generated by Ember if they are not declared. For this demo, the Application View will be handling the mouse events.</p>

<p>```coffeescript</p>

<h1>uses 'needs' API to access the box Controller</h1>

<p>App.ApplicationController = Em.Controller.extend</p>

<pre><code>needs: ['box']
</code></pre>

<p><code>
The **needs** property lists other controllers so that you can access them from this controller by using this.get('controllers.otherController'). 'otherController' being 'box' in this case.
</code>coffeescript</p>

<h1>events handled on this view</h1>

<p>App.ApplicationView = Ember.View.extend</p>

<pre><code>classNames: ["main"]

#EVENTS below
mouseDown: (event)-&gt;
    viewOffsetLeft = @$().offset().left
    viewOffsetTop = @$().offset().top
    boxCon = @get('controller.controllers.box')
    X = event.pageX - viewOffsetLeft
    Y =  event.pageY - viewOffsetTop

    boxCon.set('initialX', X)
    boxCon.set('initialY', Y)
    boxCon.createBox(X, Y)
#calculate view offsets to get accurate click positions
mouseMove: (event)-&gt;
    viewOffsetLeft = @$().offset().left
    viewOffsetTop = @$().offset().top
    boxCon = @get('controller.controllers.box')
    boxCon.updateBoxArea(event.pageX - viewOffsetLeft, 
                         event.pageY - viewOffsetTop)
#stops the box area update
mouseUp: (event)-&gt;
    boxCon = @get('controller.controllers.box')
    boxCon.set('isUpdating', false)
</code></pre>

<p>```</p>

<h3>Event Handling</h3>

<p><strong>Ember.View</strong>'s can handle many/most of the browser events, a description may be found here: <a href = "http://emberjs.com/api/classes/Ember.View.html"> Ember View API </a>.
Here we have used the mouseDown, mouseMove, and mouseUp events to capture a click and drag in the browser. We declare a 'boxCon' variable that is set to the <strong>Box Controller</strong>, which was made available
by using <strong>needs</strong> on the Application Controller. <br/> <br/>
The mouseMove event is using the pageX and pageY attributes of the event. The reason for this is moving the mouse over a <strong>Box View</strong> would give the offsets relative to that view
instead of the <strong>App View</strong>'s offsets. Since we are using event.pageX and event.pageY, we should account for the offset of the <strong>App View</strong> relative to the absolute top and left of the page.
<strong>@$()</strong> or <strong>this.$()</strong> is a jQuery element which we then call the jQuery <strong>offset()</strong> method on. This returns an object with top and left properties.
Each event then passes on the event information to the <strong>Box Controller</strong> via a method call or setting an attribute.</p>

<h2>BoxController and BoxView Setup</h2>

<p>The BoxController has an 'isUpdating' flag, and the initial coordinates of the mouseDown event. The two methods are to create a box object
at the click and to update the area of the new box based on mouse movements.
```coffeescript</p>

<h1>controller to handle the calculations on the box properties</h1>

<p>App.BoxController = Ember.ObjectController.extend</p>

<pre><code>initialX: null
initialY: null
isUpdating: false
#calculate the new properties of the box
updateBoxArea: (X,Y)-&gt;
    if @get('isUpdating')
        box = @get('content')
        origLeft = @get 'initialX'
        origTop = @get 'initialY'
        if X &gt;= origLeft
            left = origLeft
            width = X - origLeft
        else if X &lt; origLeft
            left = X
            width = origLeft - X
        if Y &gt;= origTop 
            top = origTop
            height =  Y - origTop
        else if Y &lt; origTop
            top = Y
            height = origTop - Y
        box.setProperties({left: left, top: top, height: height, width: width})
#create a new box at the click coordinates
createBox: (X, Y)-&gt;
    a = App.Box.create({top:Y, left:X})
    @set('content', a)
    @set('isUpdating', true)
</code></pre>

<p>```
The BoxView is what allows the updated box object to be displayed. <strong>attributeBindings</strong> will attach an attribute to the view element.
In this case the attribute we want is <strong>style</strong>. 'Style' is defined here as a computed property which returns a string. The result is
the view element will have style="height:50px;width=50px; etc..." This value will update whenever the properties of the box update, and
cause the view to be re-rendered.</p>

<p>```coffeescript</p>

<h1>View dynamically sets the 'style' attribute via computed property and rerenders</h1>

<p>App.BoxView = Ember.View.extend</p>

<pre><code>classNames: ['box']
attributeBindings: ['style']
contentBinding: 'controller.content'
style: (-&gt;
     height = @get('content.height')
     width = @get('content.width')
     top = @get('content.top')
     left = @get('content.left')
     heightString = "height:#{height}px;"
     widthString="width:#{width}px;"
     topString="top:#{top}px;"
     leftString="left:#{left}px;"
     return heightString + widthString + topString + leftString
 ).property('content.height', 'content.width',
            'content.top', 'content.left').cacheable()
</code></pre>

<p>```</p>

<h3>Improving the System</h3>

<p>Here is the working jsFiddle showing the results of this demo: <a href="http://jsfiddle.net/chen_pete/5m95y/10/">Completed Fiddle</a><br/><br/>
What can we improve? Currently, during the box update there is a flag on the controller called 'isUpdating' which is set to true, then when
the update ends this flag is set to false. We could run into problems in the future if we add more features and forget what this flag is for.
Then we could run into some crazy behavior since those mouse events are still firing when we move the mouse. A better solution might be to use
a state machine instead of a flag and change states when appropriate. Each state would handle events and only the appropriate outcomes would
be allowed. <br /><br/>
That wraps it up, thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Layering Canvases with Ember.ContainerView]]></title>
    <link href="http://stevekane.github.com/blog/2013/02/22/layered-canvases-with-css-extraction/"/>
    <updated>2013-02-22T01:30:00-06:00</updated>
    <id>http://stevekane.github.com/blog/2013/02/22/layered-canvases-with-css-extraction</id>
    <content type="html"><![CDATA[<h2>Dependency Versions</h2>

<p>This post was built with Ember.js 1.0.0RC1, handlebars RC3, and jQuery 1.9.1</p>

<h2>Understand The Goal</h2>

<h3>What will we explore?</h3>

<p>Our goal is to use Ember's <strong>ContainerView</strong> class to wrap up <strong>multiple HTML5 canvas elements</strong> into a single, layered display.  This pattern is extremely
common for effective use of canvas elements and Ember offers an elegant solution for encapsulating them as a "unit".</p>

<h3>Show me the end product before I listen...</h3>

<p>Feel free to check out this <a href="http://jsfiddle.net/skane/msvDW/34/">Completed Fiddle</a> or build your own fiddle as we go.</p>

<h2>Separating Signals and Noise</h2>

<p>This project, and many that follow require some "support" code to achieve the end goal.  Often times that code is not germane to the point the article is trying
to make about Ember.js.</p>

<h3>Signals</h3>

<p>Use of Container/Canvas Views<br />
Dynamic styling using computed properties<br />
Initial Canvas drawing and re-rendering<br /></p>

<h3>Noise</h3>

<p>Buttons to change linecount and supporting behavior validation<br />
Local variable setup<br />
Methods for drawing to canvas (these are worth exploring but don't directly convey our purpose here)<br /></p>

<h2>Ember setup</h2>

<p>```coffeescript
window.App = Em.Application.create()</p>

<p>App.ApplicationController = Em.Controller.extend
  #we use this instead of the more typical "content" to avoid making Application Controller angry
  appVars: Em.Object.create</p>

<pre><code>height: 300
width: 300
lineCount: 3
</code></pre>

<p>App.Canvas = Em.View.extend
  tagName: "canvas"
  isVertical: true
  didInsertElement: ()-></p>

<pre><code>@_super()
@fill()
</code></pre>

<p>  fill: ()-></p>

<pre><code>#this will be our primary drawing method (to be continued...)
return
</code></pre>

<p>App.CompositeView = Em.ContainerView.extend
  tagName: "div"
  childViews: ['canvas1', 'canvas2']</p>

<p>  canvas1: App.Canvas.create</p>

<pre><code>isVertical: false
color1: "blue"
color2: "grey"
</code></pre>

<p>  canvas2: App.Canvas.create</p>

<pre><code>color1: "red"
color2: "white"
</code></pre>

<p>```</p>

<h3>What is all this...stuff?</h3>

<p>The <strong>ApplicationController</strong> is the context for all our views in this system.  It will eventually also house a few basic methods to support some html buttons.<br />
The <strong>CompositeView</strong> is an instance of Ember's ContainerView and is used to hold the two canvases (which contain the bulk of the program's code)<br />
The <strong>Canvas Views</strong> are setup to wrap HTML5 canvas elements (see previous blogpost for details).  We instantiate two of them as we intend to build a layered display.</p>

<h2>Add a template and give our views some style</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-handlebars</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Test</span> <span class="nx">to</span> <span class="nx">confirm</span> <span class="nx">the</span> <span class="nx">template</span> <span class="nx">is</span> <span class="nx">loading</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>  <span class="p">{{</span> <span class="nx">view</span> <span class="s1">&#39;App.CompositeView&#39;</span> <span class="nx">contentBinding</span><span class="o">=</span><span class="s1">&#39;appVars&#39;</span> <span class="p">}}</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
This template is our <strong>application template</strong> (Ember automatically assigns this if no <strong>data-template-name</strong> is declared in the script tag).  We add a line to confirm
our app is rendering this template and we add a handlebars tag to create an instance of our view and bind its content to the applicationController's <strong>appVars</strong> attribute.
```coffeescript
App.CompositeView = Ember.ContainerView.extend</p>

<pre><code>tagName: "div"
#this computed property will create a CSS style string 
style: (-&gt;
    "height:" + @get('content.height') + "px;" + "width:" + @get('content.width') + "px;"
).property('content.height, content.width')
attributeBindings: ['style']
childViews: ['canvas1', 'canvas2']

canvas1: App.Canvas.create
    isVertical:  false
    color1: "blue"
    color2: "grey"
canvas2: App.Canvas.create
    color1: "red"
    color2: "white"
</code></pre>

<p><code>
This View is now complete and will not change for the rest of this post.  We have added a **computed property called "style"** to the view which constructs a string of
in-line styles to be added onto the view's element, "div", via the **attributeBindings** attribute.  Read &lt;a href="http://emberjs.com/api/classes/Ember.View.html"&gt;
Ember's View API&lt;/a&gt; for more information on how these attributes work.&lt;br /&gt;
**NOTE: This is not the only way to style an element but it showcases a method that will allow us to dynamically re-size our view if the view's content.height or content.width are changed by our application.**
</code>coffeescript
App.Canvas = Ember.View.extend</p>

<pre><code>tagName: "canvas"
contentBinding: "parentView.content"
attributeBindings: ['height', 'width']
height: (-&gt;
    @get "content.height"
).property('content.height')
width: (-&gt;
    @get "content.width"
).property('content.width')
isVertical: true

layoutChanged: (-&gt;
    @fill()
).observes('content.lineCount', 'content.height', 'content.width')

didInsertElement: ()-&gt;
    @_super()
    @fill()

fill: () -&gt;
    return
</code></pre>

<p><code>
We have again added an attributeBindings method to our view but, critically, we have utilized it differently.  In the CompositeView we used **in-line style** to set
our view's height and width.  Here, we must use the **html attributes "height" and "width"** to give dimensions to a canvas element.  This is an important
distinction.&lt;br /&gt;
Attributes **height** and **width** are implemented as computed properties that simply reflect **content.height** and **content.width**.  This again allows us
to **re-size our canvases** elsewhere in our application should we want to do so.
</code>css
div {
  position: relative;
}
canvas {
  opacity: .5;
  position: absolute;
}
```
Setting position:absolute on the canvas means they will draw directly on top of our div element rather than in normal html block format.  The results of this aren't yet apparent but they will be shortly.  We set opacity so that our layers are partially transparent.</p>

<h2>Canvas drawing code</h2>

<p>```coffeescript
App.Canvas = Ember.View.extend</p>

<pre><code>tagName: "canvas"
contentBinding: "parentView.content"
attributeBindings: ['height', 'width']
height: (-&gt;
    @get "content.height"
).property('content.height')
width: (-&gt;
    @get "content.width"
).property('content.width')
isVertical: true

layoutChanged: (-&gt;
    @fill()
).observes('content.lineCount', 'content.height', 'content.width')

didInsertElement: ()-&gt;
    @_super()
    @fill()

fill: () -&gt;
    isVertical = @get "isVertical"
    lineCount = @get "content.lineCount"
    el = @get "element"
    height = @get "content.height"
    width = @get "content.width"
    color1 = @get "color1"
    color2 =@get "color2"
    if el
        ctx = el.getContext "2d"
        for lineNum in [1..lineCount]
            color = if lineNum%2 is 0 then color2 else color1
            @drawRect ctx, color, lineNum, lineCount, isVertical, height, width
#helper method that draws each uniquely-colored box
drawRect: (ctx, color, lineNum, lineCount, isVertical, height, width) -&gt;
    if isVertical
        rHeight = height
        rStartY = 0
        rWidth = width/lineCount
        rStartX = width/lineCount * (lineNum-1)
     else 
        rHeight = height/lineCount
        rStartY = height/lineCount * (lineNum-1)
        rWidth = width
        rStartX = 0
     ctx.fillStyle = color
     ctx.fillRect rStartX, rStartY, rWidth, rHeight
</code></pre>

<p>```
This class is now finished and will not change for the rest of this post.<br />
This code looks a little dense but its purpose is very simple.  It draws <strong>horizontal</strong> or <strong>vertical</strong> stripes onto our canvases using the low-level canvas API's methods.  It is easy to google these methods so I will not explain them here.  The rest of the lines are dedicated to calculating x,y,height, and width based on our view's content (which is inherited from applicationController.appVars).  <strong>Feel free to tweet, email, or comment below if any of this is unclear</strong>.  <br />
<strong>NOTE: Be sure to remove the "return" we had listed in the fill method initially.  It was only there as filler.</strong><br />
Finally, we also implement an Ember observer called <strong>layoutChanged which fires any time content.lineCount, content.height, or content.width change</strong>.  We use this to signal to our canvas that it must re-draw itself.  We don't need to clear the canvas in this particular app because our draw process completely re-draws the whole canvas.  <strong>This may not always be the case!</strong></p>

<h2>Dynamically re-draw our canvas by changing lineCount!</h2>

<p>```coffeescript
App.ApplicationController = Ember.Controller.extend</p>

<pre><code>appVars: Ember.Object.create
    height: 300
    width: 300
    lineCount: 3
 #methods to change lineCount within range 1-&gt;10
 upLineCount: () -&gt;
    if @get("appVars.lineCount") &lt;=9
        @incrementProperty "appVars.lineCount"
    else
        @set "appVars.lineCount", 10
 downLineCount: () -&gt;
    if @get("appVars.lineCount") &gt;=1
        @decrementProperty "appVars.lineCount"
    else
        @set "appVars.lineCount", 0
</code></pre>

<p>```
These new methods on the applicationController change the lineCount attribute on appVars within the range 1->10.  We will call these methods from our template as shown below.
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-handlebars&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Use</span> <span class="nx">buttons</span> <span class="nx">to</span> <span class="nx">change</span> <span class="nx">line</span> <span class="nx">density</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nx">button</span> <span class="p">{{</span><span class="nx">action</span> <span class="s1">&#39;upLineCount&#39;</span> <span class="p">}}</span><span class="o">&gt;</span><span class="nx">Increase</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nx">button</span> <span class="p">{{</span><span class="nx">action</span> <span class="s1">&#39;downLineCount&#39;</span> <span class="p">}}</span><span class="o">&gt;</span><span class="nx">Decrease</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span><span class='line'>    <span class="p">{{</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">appVars</span><span class="p">.</span><span class="nx">lineCount</span> <span class="p">}}</span>
</span><span class='line'>    <span class="p">{{</span> <span class="nx">view</span> <span class="s1">&#39;App.CompositeView&#39;</span> <span class="nx">contentBinding</span><span class="o">=</span><span class="s1">&#39;appVars&#39;</span> <span class="p">}}</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
We have added buttons that utilize Ember's <strong>action</strong> handlebars tag to call the new methods on applicationController.  We now have a way for users to change the lineCount which creates such dreamy, dreamy patterns...</p>

<h2>Conclusion and future work</h2>

<p>Once again, here is a <a href="http://jsfiddle.net/skane/msvDW/34/">Completed Fiddle</a> showcasing this application.
This post has highlighted a pattern that we intend to elaborate on with examples of <strong>UI widgets, editable objects, and more advanced canvas APIs</strong>.  If you understand what is going on in this post and in the previous canvas post you will be prepared to do some truly useful things in Ember.js!  Who doesn't love being useful?  Cats...that's who.<br />
<strong>/golfclap<br />
/bow</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wrapping HTML5 Canvas with Ember View]]></title>
    <link href="http://stevekane.github.com/blog/2013/02/14/test-pos/"/>
    <updated>2013-02-14T23:02:00-06:00</updated>
    <id>http://stevekane.github.com/blog/2013/02/14/test-pos</id>
    <content type="html"><![CDATA[<h2>Dependency Versions</h2>

<p>This post was built with Ember.js 1.0.0pre4, handlebars RC2, and jQuery 1.9.1</p>

<h2>Understand The Goal</h2>

<h3>What is Happening Here ?</h3>

<p>We are going to use <strong>Ember.View</strong> to wrap an <strong>HTML5 &lt;canvas> element</strong>.  This will allow us to use the canvas API to draw shapes/data/whatever while utilizing Ember's data structures, route handlers, and other bells/whistles that make it so great.</p>

<h3>See Into the Future !</h3>

<p>Cheat and check out this <a href="http://jsfiddle.net/skane/NyxkD/2/">Completed Fiddle</a> Or build your <a href="http://jsfiddle.net">Own Fiddle</a> as you learn.</p>

<h2>Write Minimally Viable Ember Application (that does something)</h2>

<p>```html</p>

<script type="text/x-handlebars">
  Text to demonstrate App is functioning
</script>


<p><code>
</code>coffeescript
window.App = Em.Application.create()
```</p>

<h3>Where's the Router    ? :-/</h3>

<p>Ember generates a <strong>default router</strong> for us.  We are not changing routes so no need to explicitly declare it ourselves.</p>

<h3>Why Define The Template    ? :-/</h3>

<p>Primarily, we demonstrate our app's validity.  Secondarily, we are going to modify this to be more useful in the next section.</p>

<h2>Construct Canvas View, Modify application Template, Add CSS Border</h2>

<p>```coffeescript
window.App = Em.Application.create()</p>

<p>App.Canvas = Em.View.extend
  #attributes used to define and render the canvas
  tagName: "canvas"
  attributeBindings: ['height', 'width']
  height: 300
  width: 300
  color1: "blue"
  color2: "orange"
```
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-handlebars&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nx">Text</span> <span class="nx">to</span> <span class="nx">demonstrate</span> <span class="nx">App</span> <span class="nx">is</span> <span class="nx">functioning</span>
</span><span class='line'>  <span class="p">{{</span> <span class="nx">view</span> <span class="s1">&#39;App.Canvas&#39;</span> <span class="p">}}</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<code>css
canvas {
  border: 5px solid black;
}
</code></p>

<h3>What is the Meaning of "view App.Canvas"    ? :-/</h3>

<p>This will create a new instance of the view <strong>App.Canvas</strong> and render it into the application template.  The view has the same context as the current template
(in this case Ember has <strong>automagically generated applicationController</strong>).</p>

<h3>And the Attributes    ? :-|</h3>

<p><strong>AttributeBindings</strong> is an array of strings that references other attributes on the view.  It creates HTML attributes by those attribute names with the values stored
in each attribute.  If the attributes change on the view, they will also change in the HTML.  We are using <strong>height</strong> and <strong>width</strong> in this manner and the resulting
output is shown below.
<code>html
&lt;canvas height="300" width="300"&gt;&lt;/canvas&gt;
</code>
Attributes <strong>color1</strong> and <strong>color2</strong> are going to be used by our application to determine what colors to paint our canvas.  More on that to come...</p>

<h2>Hook Into DOM Insertion and Design a Fill Method</h2>

<p>```coffeescript
window.App = Em.Application.create()</p>

<p>App.Canvas = Em.View.extend
  #attributes used to define and render the canvas
  tagName: "canvas"
  attributeBindings: ['height', 'width']
  height: 300
  width: 300
  color1: "blue"
  color2: "orange"</p>

<p>  #this method is fired when this view's element is inserted in the DOM
  didInsertElement: () -></p>

<pre><code>@_super()
@fill()
</code></pre>

<p>  fill: () -></p>

<pre><code>#local variables for clarity
halfHeight = @get('height') / 2
width = @get "width"
c1 = @get "color1"
c2 = @get "color2"

#draw canvas parameters and methods (basic canvas api)
ctx = el.getContext "2d"
ctx.fillStyle = c1
ctx.fillRect 0, 0, width, halfHeight
ctx.fillStyle = c2
ctx.fillRect 0, halfHeight, width, halfHeight
</code></pre>

<p>```</p>

<h3>What Are These New Methods ?     (╯°□°)╯︵ ┻━┻</h3>

<p><strong>didInsertElement</strong> is a method baked into Ember.View that fires when the view's element (in our case, canvas) is inserted into the DOM.
This method may be overridden to call our <strong>fill</strong> method initially.<br /><br />
<strong>fill</strong> is a method that we have defined that uses the low-level canvas drawing API to color half the canvas orange
 and half the canvas blue.  You can easily read about these methods on <a href="http://developer.mozilla.org">MDN</a> or
a number of other references.</p>

<h3>Draw Using Any Canvas API You Prefer !     ┬─┬ ノ(゜-゜ノ)</h3>

<p>You could easily load one of many, many <a href="https://docs.google.com/spreadsheet/ccc?key=0Aqj_mVmuz3Y8dHNhUVFDYlRaaXlyX0xYSTVnalV5ZlE#gid=0">Canvas 2d Libraries</a>
and use them to draw whatever you want in reaction to DOM events, user interaction, or even animations.</p>

<h3>Tell Me More About this...Event Handling ! :-)</h3>

<p>We can easily use the browser's events such as <strong>click</strong>, <strong>doubleClick</strong>, <strong>mouseEnter</strong> etc to bind functions on our view to those events.  Ember provides method hooks
for these events with obvious names.  A complete list of these is found <a href="https://emberjs.com/api/classes/Ember.View.html">Here</a>.</p>

<h2>I Hold Tight To Your Hand As We Step Into This Brave New World</h2>

<p>```coffeescript
window.App = Em.Application.create()</p>

<p>App.Canvas = Em.View.extend
  #attributes used to define and render the canvas
  tagName: "canvas"
  attributeBindings: ['height', 'width']
  height: 300
  width: 300
  color1: "blue"
  color2: "orange"</p>

<p>  #this method is fired when this view's element is inserted in the DOM
  didInsertElement: () -></p>

<pre><code>@_super()
@fill()
</code></pre>

<p>  fill: () -></p>

<pre><code>#local variables for clarity
halfHeight = @get('height') / 2
width = @get "width"
c1 = @get "color1"
c2 = @get "color2"

#draw canvas parameters and methods (basic canvas api)
ctx = el.getContext "2d"
ctx.fillStyle = c1
ctx.fillRect 0, 0, width, halfHeight
ctx.fillStyle = c2
ctx.fillRect 0, halfHeight, width, halfHeight

#click event handler
click: (event)-&gt;
  c1 = @get "color1"
  c2 = @get "color2"
  @set "color1", c2
  @set "color2", c1
  @fill()
</code></pre>

<p>```</p>

<h3>Click the Box Repeatedly To Feel that <a href="http://www.illinois.edu">Illini Pride</a></h3>

<p>Our <strong>click</strong> event handles all browser click events that target our <strong>canvas</strong> and swaps the colors before calling <strong>fill</strong> again.<br/>
Consider what else you might do with such an event handler: <br />
<strong>mouseMove</strong> could be used to capture mouse coordinates and draw directly onto the canvas<br />
<strong>keyDown</strong> could be used to capture keys and output printed text in the canvas<br />
<strong>etc etc etc</strong><br />
If you make an interesting feature and would like to share your fiddle, shoot me a tweet and I'll append your fiddle to this blog post for others to learn from.</p>

<h2>En Futuro</h2>

<h3>Explore Options for Nested Canvas Elements</h3>

<p>Nested canvas elements may be used as overlays on top of classical HTML elements which allows you to blend per-pixel drawing with standard HTML/CSS skills.</p>

<h3>Explore Options for Using Advanced Canvas APIs</h3>

<p>Advaned canvas APIs offer greater flexibility and higher-level abstractions useful for quickly producing impressive results.</p>

<h3>Explore Options for Rendering Using WebGL (2d/3d)</h3>

<p>WebGL is the bees knees and Ember.js has potential to weave together the rendering power of WebGL with Ember's data management systems.  <strong>Ermagerd...werb GR ER</strong></p>
]]></content>
  </entry>
  
</feed>
